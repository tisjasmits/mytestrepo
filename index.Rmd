---
title: "Test file"
author: "Tisja Smits"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

## Two hashes = main heading
### Three hashes = subheading
#### Four hashes = subsubheading

One star is *italics*. Two stars is **bold**.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document.


## Week 5

### Breakout 2

Every analysis you do for this class must start with the following two lines, which load the `tidyverse` and `spotifyr` packages.

```{r load packages}
library(tidyverse)
library(spotifyr)
```

The `spotifyr` library allows you to load information by track, album, artist, or playlist. I very strongly recommend using playlists. 

All of the functions rely on Spotify URIs. You can copy them from spotify, but you need to delete the first parts (e.g., `spotify:track:`, `spotify:album:`, `spotify:artist:`, or `spotify:playlist:`) and keep only the alphanumeric nonsense at the end. Note also that `get_playlist_audio_features()` requires an extra blank string at the beginning, for historical reasons.

Sometimes you will get a warning message that *`mutate_()` is deprecated as of dplyr 0.7.0*. You can ignore it. The `tidyverse` package is undergoing some transition right now, and the `spotifyr` developers are still working to catch up.


```{r load Spotify data}
juditha <- get_track_audio_features(c("2M5b9YLAgFroqWzeaZf86e", "3DBKc4ioGnMQLlbGQcFDIO"))
alla <- get_album_tracks("7oI0E3DdTbD85rhMg19GSU")
gilberto <- get_artist_audio_features("gilberto gil")
ecm <- get_playlist_audio_features("", "1zN4nK6oHMo2dei2WWPtSL")
```

After you load these features, the easiest way to look at them is to click on the variable in the Environment tab in the top-right pane of RStudio. That will open a full, sortable, spreadsheet-style summary of your data.

But you can also compute summary statistics with the `summary()` function.

```{r summarize data}
ecm %>%
  summarise(
    mean_speechiness = mean(speechiness),
    mean_acousticness = mean(acousticness),
    mean_liveness = mean(liveness),
    sd_speechiness = sd(speechiness),
    sd_acousticness = sd(acousticness),
    sd_liveness = sd(liveness),
    median_speechiness = median(speechiness),
    median_acousticness = median(acousticness),
    median_liveness = median(liveness),
    mad_speechiness = mad(speechiness),
    mad_acousticness = mad(acousticness),
    mad_liveness = mad(liveness)
  )
```


### Breakout 3

Let's start by loading playlists from the recent Grammy and Edison awards.

```{r loading playlists}
grammy <- get_playlist_audio_features("", "4kQovkgBZTd8h2HCM3fF31")
edison <- get_playlist_audio_features("", "37i9dQZF1DX8mnKbIkppDf")
```

Next, let's combine data sets with a labelling variable. This is the strategy I recommend for your portfolios: make a separate Spotify playlist for each category in your corpus, and then combine them with a `category` label like the example below.

```{r combining data sets}
awards <-
  bind_rows(
    grammy %>% mutate(category = "Grammys"),
    edison %>% mutate(category = "Edisons")
  )
```

The simplest data visualisation of a single, continuous variable is a histogram.

```{r example histogram}
grammy %>% ggplot(aes(x = energy)) + geom_histogram(binwidth = 0.1)
```

If you want to compare a continuous variable across categories, you can use *faceting* (also known as *small multiples*), a *boxplot* or a *violin plot*.

```{r example plots}
awards %>%
  ggplot(aes(x = energy)) +
  geom_histogram(binwidth = 0.1) +
  facet_wrap(~category)
awards %>%
  ggplot(aes(x = category, y = energy)) +
  geom_boxplot()
awards %>%
  ggplot(aes(x = category, y = energy)) +
  geom_violin()
```

To compare *two* continuous variables, you can create a scatter plot. If you have a large corpus and the points end up on top of each other, `geom_jitter()` adds some random noise without disturbing the overall pattern.

```{r grammy plot}
grammy %>% ggplot(aes(x = valence, y = energy)) + geom_point() + geom_smooth()
grammy %>% ggplot(aes(x = valence, y = energy)) + geom_jitter() + geom_smooth()
```

Good visualisations, of course, have many more components. Remember Tufte's six design principles (2006):
  1. Show comparisons, contrasts, differences.
  2. Show causality, mechanism, explanation, systematic structure.
  3. Show multivariate data; that is, show more than 1 or 2 variables.
  4. Completely integrate words, numbers, images, diagrams.
  5. Thoroughly describe the evidence. Provide a detailed title, indicate the authors and sponsors, document the data sources, show complete measurement scales, point out relevant issues.
  6. Analytical presentations ultimately stand or fall on the quality, relevance, and integrity of their content.

```{r awards plot}
awards %>%                    # Start with awards.
  mutate(
    mode = ifelse(mode == 0, "Minor", "Major")
  ) %>%
  ggplot(                     # Set up the plot.
    aes(
      x = valence,
      y = energy,
      size = loudness,
      colour = mode
    )
  ) +
  geom_point() +              # Scatter plot.
  geom_rug(size = 0.1) +      # Add 'fringes' to show data distribution.
  geom_text(                  # Add text labels from above.
    aes(
      x = valence,
      y = energy,
      label = label
    ),
    data = 
      tibble(
        label = c("Altijd wel iemand", "ENERGY"),
        category = c("Edisons", "Grammys"),
        valence = c(0.090, 0.123),
        energy = c(0.101, 0.967)
      ),
    colour = "black",         # Override colour (not mode here).
    size = 3,                 # Override size (not loudness here).
    hjust = "left",           # Align left side of label with the point.
    vjust = "bottom",         # Align bottom of label with the point.
    nudge_x = -0.05,          # Nudge the label slightly left.
    nudge_y = 0.02            # Nudge the label slightly up.
  ) +
  facet_wrap(~category) +     # Separate charts per playlist.
  scale_x_continuous(         # Fine-tune the x axis.
    limits = c(0, 1),
    breaks = c(0, 0.50, 1),   # Use grid-lines for quadrants only.
    minor_breaks = NULL       # Remove 'minor' grid-lines.
  ) +
  scale_y_continuous(         # Fine-tune the y axis in the same way.
    limits = c(0, 1),
    breaks = c(0, 0.50, 1),
    minor_breaks = NULL
  ) +
  scale_colour_brewer(        # Use the Color Brewer to choose a palette.
    type = "qual",            # Qualitative set.
    palette = "Paired"        # Name of the palette is 'Paired'.
  ) +
  scale_size_continuous(      # Fine-tune the sizes of each point.
    trans = "exp",            # Use an exp transformation to emphasise loud.
    guide = "none"            # Remove the legend for size.
  ) +
  theme_light() +             # Use a simpler theme.
  labs(                       # Make the titles nice.
    x = "Valence",
    y = "Energy",
    colour = "Mode"
  )
```

#### Digster exercise

Below, I used `echo = FALSE` to hide the R code setting the plot.

```{r Digster plot, echo=FALSE}
digster90 <- get_playlist_audio_features("", "0MmrdphoTkHhChZR5ympER")
digster00 <- get_playlist_audio_features("", "6dv5FbNRVlQelteqnNDFTe")

digster <-
  bind_rows(
    digster90 %>% mutate(category = "90's"),
    digster00 %>% mutate(category = "00's")
  )

digster %>%                    # Start with awards.
  mutate(
    mode = ifelse(mode == 0, "Minor", "Major")
  ) %>%
  ggplot(                     # Set up the plot.
    aes(
      x = tempo,
      y = danceability,
      size = loudness,
      colour = mode
    )
  ) +
  geom_point() +              # Scatter plot.
  geom_rug(size = 0.1) +      # Add 'fringes' to show data distribution.
  
  facet_wrap(~category) +     # Separate charts per playlist.
  scale_x_continuous(         # Fine-tune the x axis.
    #limits = c(0, 1),
    breaks = c(0, 0.50, 1),   # Use grid-lines for quadrants only.
    minor_breaks = NULL       # Remove 'minor' grid-lines.
  ) +
  scale_y_continuous(         # Fine-tune the y axis in the same way.
    limits = c(0, 1),
    breaks = c(0, 0.50, 1),
    minor_breaks = NULL
  ) +
  scale_colour_brewer(        # Use the Color Brewer to choose a palette.
    type = "qual",            # Qualitative set.
    palette = "Paired"        # Name of the palette is 'Paired'.
  ) +
  scale_size_continuous(      # Fine-tune the sizes of each point.
    trans = "exp",            # Use an exp transformation to emphasise loud.
    guide = "none"            # Remove the legend for size.
  ) +
  theme_light() +             # Use a simpler theme.
  labs(                       # Make the titles nice.
    x = "Tempo",
    y = "Danceability",
    colour = "Mode"
  )
```